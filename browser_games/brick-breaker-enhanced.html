
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Brick Breaker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #0a0e27;
            overflow: hidden;
            touch-action: none;
            font-family: 'Arial', sans-serif;
        }
        
        canvas {
            display: block;
            background: #0a0e27;
            cursor: none;
        }
        
        #blankedScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            justify-content: center;
            align-items: center;
            color: #666;
            font-size: 24px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="blankedScreen">Touch to wake</div>
    
    <script>
        'use strict';
        
        // ===== GAME CONSTANTS =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blankedScreen = document.getElementById('blankedScreen');
        
        // LED Control Interface (if available)
        const LEDController = {
            available: false,
            
            init() {
                // Check if LED control is available via sysfs
                this.available = typeof window.fetch !== 'undefined';
            },
            
            async setLED(color, brightness) {
                if (!this.available) return;
                try {
                    // Attempt to control LEDs via system interface
                    // This would require a backend endpoint or direct sysfs access
                    const ledPath = color === 'red' ? '/sys/class/leds/red_led/brightness' : 
                                   color === 'green' ? '/sys/class/leds/green_led/brightness' : null;
                    if (ledPath) {
                        // In a real implementation, this would call a backend service
                        console.log(`LED ${color}: ${brightness}`);
                    }
                } catch (e) {
                    console.log('LED control not available');
                }
            },
            
            async flash(color, times = 3) {
                for (let i = 0; i < times; i++) {
                    await this.setLED(color, 100);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await this.setLED(color, 0);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            },
            
            async levelComplete() {
                await this.flash('green', 3);
            },
            
            async powerUpCollected() {
                await this.setLED('green', 100);
                setTimeout(() => this.setLED('green', 0), 200);
            },
            
            async ballLost() {
                await this.flash('red', 2);
            },
            
            async gameOver() {
                await this.flash('red', 5);
            }
        };
        
        // Difficulty configurations
        const DIFFICULTY_CONFIGS = {
            beginner: {
                name: 'BEGINNER',
                ballSpeedMultiplier: 0.8,
                powerUpDurationMultiplier: 1.5,
                color: '#00ff00'
            },
            advanced: {
                name: 'ADVANCED',
                ballSpeedMultiplier: 1.0,
                powerUpDurationMultiplier: 1.0,
                color: '#ffaa00'
            },
            master: {
                name: 'MASTER',
                ballSpeedMultiplier: 1.2,
                powerUpDurationMultiplier: 0.7,
                color: '#ff0000'
            }
        };
        
        // Game configuration
        const CONFIG = {
            LIVES: 5,
            MAX_LEVEL: 15,
            SCREEN_BLANK_TIMEOUT: 300000, // 5 minutes
            PADDLE_SPEED: 12,
            BALL_SPEED_BASE: 9, // Increased from 6.6 for faster initial speed
            BALL_SPEED_INCREMENT: 0.2, // Increased from 0.1 for more aggressive acceleration
            BALL_SPEED_MAX: 20, // Increased from 12 for higher top speed
            BRICK_ROWS: 6,
            BRICK_COLS: 12,
            BRICK_PADDING: 5,
            BRICK_OFFSET_TOP: 80,
            BRICK_OFFSET_LEFT: 30,
            POWER_UP_CHANCE: 0.3,
            POWER_UP_BASE_DURATION: 25000, // Increased from 10000 to 25 seconds
            FPS: 60,
            FIXED_DELTA: 16.67
        };
        
        // Brick pattern generators
        const BRICK_PATTERNS = {
            standard: (rows, cols, brickWidth, brickHeight, health) => {
                const bricks = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = CONFIG.BRICK_OFFSET_LEFT + col * (brickWidth + CONFIG.BRICK_PADDING);
                        const y = CONFIG.BRICK_OFFSET_TOP + row * (brickHeight + CONFIG.BRICK_PADDING);
                        bricks.push({ x, y, health: health[row] });
                    }
                }
                return bricks;
            },
            
            diagonal: (rows, cols, brickWidth, brickHeight, health) => {
                const bricks = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if ((row + col) % 2 === 0) {
                            const x = CONFIG.BRICK_OFFSET_LEFT + col * (brickWidth + CONFIG.BRICK_PADDING);
                            const y = CONFIG.BRICK_OFFSET_TOP + row * (brickHeight + CONFIG.BRICK_PADDING);
                            bricks.push({ x, y, health: health[row] });
                        }
                    }
                }
                return bricks;
            },
            
            checkerboard: (rows, cols, brickWidth, brickHeight, health) => {
                const bricks = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if ((row + col) % 2 === 0) {
                            const x = CONFIG.BRICK_OFFSET_LEFT + col * (brickWidth + CONFIG.BRICK_PADDING);
                            const y = CONFIG.BRICK_OFFSET_TOP + row * (brickHeight + CONFIG.BRICK_PADDING);
                            bricks.push({ x, y, health: health[row] });
                        }
                    }
                }
                return bricks;
            },
            
            pyramid: (rows, cols, brickWidth, brickHeight, health) => {
                const bricks = [];
                for (let row = 0; row < rows; row++) {
                    const bricksInRow = cols - row * 2;
                    if (bricksInRow <= 0) continue;
                    const startCol = Math.floor((cols - bricksInRow) / 2);
                    for (let i = 0; i < bricksInRow; i++) {
                        const col = startCol + i;
                        const x = CONFIG.BRICK_OFFSET_LEFT + col * (brickWidth + CONFIG.BRICK_PADDING);
                        const y = CONFIG.BRICK_OFFSET_TOP + row * (brickHeight + CONFIG.BRICK_PADDING);
                        bricks.push({ x, y, health: health[row] });
                    }
                }
                return bricks;
            },
            
            circular: (rows, cols, brickWidth, brickHeight, health) => {
                const bricks = [];
                const centerX = cols / 2;
                const centerY = rows / 2;
                const maxRadius = Math.min(cols, rows) / 2;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const dx = col - centerX;
                        const dy = row - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= maxRadius) {
                            const x = CONFIG.BRICK_OFFSET_LEFT + col * (brickWidth + CONFIG.BRICK_PADDING);
                            const y = CONFIG.BRICK_OFFSET_TOP + row * (brickHeight + CONFIG.BRICK_PADDING);
                            bricks.push({ x, y, health: health[row] });
                        }
                    }
                }
                return bricks;
            },
            
            wave: (rows, cols, brickWidth, brickHeight, health) => {
                const bricks = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const wave = Math.sin(col * 0.5) * 2;
                        if (Math.abs(row - (rows / 2 + wave)) < 1.5) {
                            const x = CONFIG.BRICK_OFFSET_LEFT + col * (brickWidth + CONFIG.BRICK_PADDING);
                            const y = CONFIG.BRICK_OFFSET_TOP + row * (brickHeight + CONFIG.BRICK_PADDING);
                            bricks.push({ x, y, health: health[Math.min(row, health.length - 1)] });
                        }
                    }
                }
                return bricks;
            }
        };
        
        // ===== GAME STATE =====
        let gameState = {
            screen: 'difficulty',
            difficulty: null,
            score: 0,
            lives: CONFIG.LIVES,
            level: 1,
            highScore: 0,
            totalBricksDestroyed: 0,
            bricksDestroyedThisGame: 0,
            lastActivity: Date.now(),
            blanked: false,
            ballLaunched: false,
            showControls: true,
            controlsFadeTime: 0
        };
        
        // ===== GAME OBJECTS =====
        let paddle, balls, bricks, powerUps;
        let activePowerUps = [];
        
        // Object pools for performance
        const ballPool = [];
        const powerUpPool = [];
        
        // Cached values for performance
        let cachedScale = 1;
        let cachedBrickWidth = 0;
        let cachedBrickHeight = 0;
        
        // ===== CLASSES =====
        class Paddle {
            constructor() {
                this.width = 100;
                this.height = 20;
                this.x = 0;
                this.y = 0;
                this.baseWidth = 100;
                this.color = '#00ffff';
                this.targetX = 0;
            }
            
            update(scale) {
                this.width = this.baseWidth * scale;
                this.height = 20 * scale;
                this.y = canvas.height - 40 * scale;
                this.x = this.targetX;
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            
            setTargetX(x) {
                this.targetX = x - this.width / 2;
            }
        }
        
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 8;
                this.dx = 0;
                this.dy = 0;
                const difficultyMultiplier = gameState.difficulty ? 
                    DIFFICULTY_CONFIGS[gameState.difficulty].ballSpeedMultiplier : 1.0;
                this.baseSpeed = CONFIG.BALL_SPEED_BASE * difficultyMultiplier;
                this.speed = this.baseSpeed;
                this.active = true;
                this.stuck = true;
                this.bazooka = false;
            }
            
            launch() {
                if (this.stuck) {
                    const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                    this.dx = Math.cos(angle) * this.speed;
                    this.dy = Math.sin(angle) * this.speed;
                    this.stuck = false;
                }
            }
            
            increaseSpeed() {
                if (this.speed < CONFIG.BALL_SPEED_MAX) {
                    this.speed = Math.min(this.speed + CONFIG.BALL_SPEED_INCREMENT, CONFIG.BALL_SPEED_MAX);
                    const magnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                    if (magnitude > 0) {
                        this.dx = (this.dx / magnitude) * this.speed;
                        this.dy = (this.dy / magnitude) * this.speed;
                    }
                }
            }
            
            update() {
                if (this.stuck) {
                    this.x = paddle.x + paddle.width / 2;
                    this.y = paddle.y - this.radius;
                    return;
                }
                
                this.x += this.dx;
                this.y += this.dy;
                
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.dx = -this.dx;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                
                if (this.y - this.radius < 0) {
                    this.dy = -this.dy;
                    this.y = this.radius;
                }
                
                if (this.y + this.radius > paddle.y &&
                    this.y - this.radius < paddle.y + paddle.height &&
                    this.x > paddle.x &&
                    this.x < paddle.x + paddle.width) {
                    
                    this.dy = -Math.abs(this.dy);
                    this.y = paddle.y - this.radius;
                    const hitPos = (this.x - paddle.x) / paddle.width;
                    this.dx = (hitPos - 0.5) * this.speed * 2;
                }
                
                if (this.y - this.radius > canvas.height) {
                    this.active = false;
                }
            }
            
            draw() {
                ctx.fillStyle = this.bazooka ? '#ff8800' : '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class Brick {
            constructor(x, y, health) {
                this.x = x;
                this.y = y;
                this.width = 0;
                this.height = 0;
                this.health = health;
                this.maxHealth = health;
                this.active = true;
            }
            
            getColor() {
                const colors = ['#00ff00', '#ffff00', '#ff8800', '#ff0000'];
                return colors[Math.min(this.health - 1, colors.length - 1)];
            }
            
            hit(isBazooka = false) {
                if (isBazooka) {
                    this.health = 0;
                } else {
                    this.health--;
                }
                
                if (this.health <= 0) {
                    this.active = false;
                    gameState.score += 10 * gameState.level;
                    gameState.totalBricksDestroyed++;
                    gameState.bricksDestroyedThisGame++;
                    
                    if (Math.random() < CONFIG.POWER_UP_CHANCE) {
                        spawnPowerUp(this.x + this.width / 2, this.y + this.height / 2);
                    }
                    return true;
                }
                return false;
            }
            
            draw() {
                if (!this.active) return;
                ctx.fillStyle = this.getColor();
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                if (this.health > 1) {
                    ctx.fillStyle = '#000';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.health, this.x + this.width / 2, this.y + this.height / 2 + 4);
                }
            }
        }
        
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.speed = 2;
                this.size = 20;
                this.active = true;
            }
            
            update() {
                this.y += this.speed;
                
                if (this.y > canvas.height) {
                    this.active = false;
                }
                
                if (this.active &&
                    this.x > paddle.x &&
                    this.x < paddle.x + paddle.width &&
                    this.y + this.size > paddle.y) {
                    this.active = false;
                    applyPowerUp(this.type);
                }
            }
            
            draw() {
                const config = POWER_UP_TYPES[this.type];
                ctx.fillStyle = config.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(config.symbol, this.x, this.y);
            }
        }
        
        // ===== POWER-UP TYPES =====
        const POWER_UP_TYPES = {
            expand: { color: '#00ff00', symbol: 'W', duration: CONFIG.POWER_UP_BASE_DURATION, name: 'Wide Paddle' },
            shrink: { color: '#ff0000', symbol: 'N', duration: CONFIG.POWER_UP_BASE_DURATION, name: 'Narrow Paddle' },
            multiball: { color: '#0088ff', symbol: 'M', duration: 0, name: 'Multi-Ball' },
            slow: { color: '#ffff00', symbol: 'S', duration: CONFIG.POWER_UP_BASE_DURATION * 1.5, name: 'Slow Ball' },
            bazooka: { color: '#ff8800', symbol: 'B', duration: CONFIG.POWER_UP_BASE_DURATION, name: 'Bazooka Ball' },
            life: { color: '#ff00ff', symbol: '+', duration: 0, name: 'Extra Life' }
        };
        
        // ===== LEVEL CONFIGURATIONS =====
        const LEVEL_CONFIGS = [
            { rows: 3, brickHealth: [1, 1, 1], pattern: 'standard' },
            { rows: 4, brickHealth: [1, 1, 2, 1], pattern: 'standard' },
            { rows: 4, brickHealth: [2, 1, 2, 1], pattern: 'diagonal' },
            { rows: 5, brickHealth: [2, 2, 1, 2, 1], pattern: 'checkerboard' },
            { rows: 5, brickHealth: [2, 2, 2, 2, 1], pattern: 'pyramid' },
            { rows: 5, brickHealth: [3, 2, 2, 2, 1], pattern: 'circular' },
            { rows: 6, brickHealth: [3, 2, 2, 2, 2, 1], pattern: 'wave' },
            { rows: 6, brickHealth: [3, 3, 2, 2, 2, 1], pattern: 'diagonal' },
            { rows: 6, brickHealth: [3, 3, 3, 2, 2, 1], pattern: 'checkerboard' },
            { rows: 6, brickHealth: [3, 3, 3, 3, 2, 1], pattern: 'pyramid' },
            { rows: 6, brickHealth: [4, 3, 3, 3, 2, 1], pattern: 'circular' },
            { rows: 6, brickHealth: [4, 4, 3, 3, 2, 1], pattern: 'wave' },
            { rows: 6, brickHealth: [4, 4, 4, 3, 2, 1], pattern: 'diagonal' },
            { rows: 6, brickHealth: [4, 4, 4, 4, 3, 1], pattern: 'checkerboard' },
            { rows: 6, brickHealth: [4, 4, 4, 4, 4, 2], pattern: 'circular' }
        ];
        
        // ===== INITIALIZATION =====
        function init() {
            LEDController.init();
            setupCanvas();
            loadGameData();
            resetGame();
            setupEventListeners();
            gameLoop();
        }
        
        function setupCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cachedScale = Math.min(canvas.width / 800, canvas.height / 600);
            paddle = new Paddle();
            paddle.baseWidth = 100 * cachedScale;
            paddle.update(cachedScale);
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.targetX = paddle.x;
        }
        
        function resetGame() {
            gameState.lives = CONFIG.LIVES;
            gameState.score = 0;
            gameState.level = 1;
            gameState.ballLaunched = false;
            gameState.bricksDestroyedThisGame = 0;
            resetLevel();
        }
        
        function resetLevel() {
            balls = [new Ball(canvas.width / 2, canvas.height - 60)];
            powerUps = [];
            activePowerUps = [];
            gameState.ballLaunched = false;
            paddle.baseWidth = 100 * cachedScale;
            createBricks();
        }
        
        function createBricks() {
            bricks = [];
            const config = LEVEL_CONFIGS[Math.min(gameState.level - 1, LEVEL_CONFIGS.length - 1)];
            cachedBrickWidth = (canvas.width - CONFIG.BRICK_OFFSET_LEFT * 2 - CONFIG.BRICK_PADDING * (CONFIG.BRICK_COLS - 1)) / CONFIG.BRICK_COLS;
            cachedBrickHeight = 25 * cachedScale;
            
            const pattern = BRICK_PATTERNS[config.pattern] || BRICK_PATTERNS.standard;
            const brickData = pattern(config.rows, CONFIG.BRICK_COLS, cachedBrickWidth, cachedBrickHeight, config.brickHealth);
            
            brickData.forEach(data => {
                const brick = new Brick(data.x, data.y, data.health);
                brick.width = cachedBrickWidth;
                brick.height = cachedBrickHeight;
                bricks.push(brick);
            });
        }
        
        // ===== GAME LOGIC =====
        function update(deltaTime) {
            if (gameState.screen !== 'playing') return;
            
            paddle.update(cachedScale);
            
            // Batch ball updates
            for (let i = 0; i < balls.length; i++) {
                balls[i].update();
            }
            
            // Optimized collision detection
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                if (ball.stuck) continue;
                
                for (let j = 0; j < bricks.length; j++) {
                    const brick = bricks[j];
                    if (!brick.active) continue;
                    
                    if (ball.x + ball.radius > brick.x &&
                        ball.x - ball.radius < brick.x + brick.width &&
                        ball.y + ball.radius > brick.y &&
                        ball.y - ball.radius < brick.y + brick.height) {
                        
                        const destroyed = brick.hit(ball.bazooka);
                        
                        if (!ball.bazooka) {
                            const overlapLeft = ball.x + ball.radius - brick.x;
                            const overlapRight = brick.x + brick.width - (ball.x - ball.radius);
                            const overlapTop = ball.y + ball.radius - brick.y;
                            const overlapBottom = brick.y + brick.height - (ball.y - ball.radius);
                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                            
                            if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                                ball.dx = -ball.dx;
                            } else {
                                ball.dy = -ball.dy;
                            }
                        }
                        
                        if (destroyed) {
                            ball.increaseSpeed();
                        }
                    }
                }
            }
            
            balls = balls.filter(ball => ball.active);
            
            if (balls.length === 0) {
                gameState.lives--;
                LEDController.ballLost();
                if (gameState.lives <= 0) {
                    gameOver();
                } else {
                    balls.push(new Ball(canvas.width / 2, canvas.height - 60));
                    gameState.ballLaunched = false;
                }
            }
            
            // Batch power-up updates
            for (let i = 0; i < powerUps.length; i++) {
                powerUps[i].update();
            }
            powerUps = powerUps.filter(powerUp => powerUp.active);
            
            const now = Date.now();
            activePowerUps = activePowerUps.filter(powerUp => {
                if (now > powerUp.endTime) {
                    removePowerUp(powerUp.type);
                    return false;
                }
                return true;
            });
            
            const activeBricks = bricks.filter(brick => brick.active);
            if (activeBricks.length === 0) {
                levelComplete();
            }
            
            if (gameState.showControls) {
                gameState.controlsFadeTime += deltaTime;
                if (gameState.controlsFadeTime > 3000) {
                    gameState.showControls = false;
                }
            }
            
            checkScreenBlanking();
        }
        
        function render() {
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState.screen === 'difficulty') {
                drawDifficultyScreen();
            } else if (gameState.screen === 'start') {
                drawStartScreen();
            } else if (gameState.screen === 'playing') {
                drawGame();
            } else if (gameState.screen === 'paused') {
                drawGame();
                drawPauseScreen();
            } else if (gameState.screen === 'gameover') {
                drawGame();
                drawGameOverScreen();
            } else if (gameState.screen === 'levelcomplete') {
                drawGame();
                drawLevelCompleteScreen();
            }
        }
        
        function drawGame() {
            // Batch drawing operations
            for (let i = 0; i < bricks.length; i++) {
                bricks[i].draw();
            }
            for (let i = 0; i < powerUps.length; i++) {
                powerUps[i].draw();
            }
            paddle.draw();
            for (let i = 0; i < balls.length; i++) {
                balls[i].draw();
            }
            drawHUD();
            if (gameState.showControls) drawControls();
        }
        
        function drawHUD() {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            
            drawButton(10, 10, 50, 35, '⏸', '#ffaa00');
            
            ctx.textAlign = 'left';
            ctx.fillText(`Level: ${gameState.level}`, 70, 35);
            
            ctx.textAlign = 'center';
            ctx.fillText(`Score: ${gameState.score}`, canvas.width / 2, 35);
            
            ctx.textAlign = 'right';
            for (let i = 0; i < gameState.lives; i++) {
                ctx.fillText('♥', canvas.width - 20 - i * 30, 35);
            }
            
            let powerUpY = 70;
            activePowerUps.forEach(powerUp => {
                const config = POWER_UP_TYPES[powerUp.type];
                const remaining = Math.ceil((powerUp.endTime - Date.now()) / 1000);
                ctx.fillStyle = config.color;
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${config.name}: ${remaining}s`, 10, powerUpY);
                powerUpY += 25;
            });
        }
        
        function drawControls() {
            const alpha = Math.max(0, 1 - gameState.controlsFadeTime / 1000);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Touch and drag to move paddle', canvas.width / 2, canvas.height - 40);
            ctx.fillText('Tap to launch ball', canvas.width / 2, canvas.height - 20);
            ctx.globalAlpha = 1;
        }
        
        function drawButton(x, y, width, height, text, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${height * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x + width / 2, y + height / 2);
        }
        
        function drawDifficultyScreen() {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BRICK BREAKER', canvas.width / 2, canvas.height / 4);
            
            ctx.font = '24px Arial';
            ctx.fillText('Select Difficulty', canvas.width / 2, canvas.height / 3);
            
            const buttonWidth = 200;
            const buttonHeight = 60;
            const buttonSpacing = 80;
            const startY = canvas.height / 2;
            
            Object.keys(DIFFICULTY_CONFIGS).forEach((key, index) => {
                const config = DIFFICULTY_CONFIGS[key];
                const y = startY + index * buttonSpacing;
                drawButton(canvas.width / 2 - buttonWidth / 2, y, buttonWidth, buttonHeight, config.name, config.color);
            });
        }
        
        function drawStartScreen() {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BRICK BREAKER', canvas.width / 2, canvas.height / 4);
            
            ctx.font = '20px Arial';
            const instructions = [
                'Break all bricks to advance',
                'Collect power-ups for advantages',
                'Touch and drag to move paddle',
                'Tap to launch ball',
                '',
                `High Score: ${gameState.highScore}`
            ];
            
            instructions.forEach((text, i) => {
                ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 60 + i * 30);
            });
            
            drawButton(canvas.width / 2 - 100, canvas.height - 150, 200, 60, 'START', '#00ff00');
        }
        
        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 50);
            
            drawButton(canvas.width / 2 - 100, canvas.height / 2 + 20, 200, 60, 'RESUME', '#00ff00');
        }
        
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 100);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 - 40);
            ctx.fillText(`Level Reached: ${gameState.level}`, canvas.width / 2, canvas.height / 2);
            ctx.fillText(`Bricks Destroyed: ${gameState.bricksDestroyedThisGame}`, canvas.width / 2, canvas.height / 2 + 40);
            
            if (gameState.score > gameState.highScore) {
                ctx.fillStyle = '#ffff00';
                ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height / 2 + 80);
            }
            
            drawButton(canvas.width / 2 - 100, canvas.height - 150, 200, 60, 'RESTART', '#00ff00');
        }
        
        function drawLevelCompleteScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 50);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.fillText(`Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
            
            drawButton(canvas.width / 2 - 100, canvas.height / 2 + 80, 200, 60, 'NEXT LEVEL', '#00ff00');
        }
        
        // ===== POWER-UP FUNCTIONS =====
        function spawnPowerUp(x, y) {
            const types = Object.keys(POWER_UP_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];
            powerUps.push(new PowerUp(x, y, type));
        }
        
        function applyPowerUp(type) {
            LEDController.powerUpCollected();
            
            const difficultyMultiplier = gameState.difficulty ?
                DIFFICULTY_CONFIGS[gameState.difficulty].powerUpDurationMultiplier : 1.0;
            
            switch (type) {
                case 'expand':
                    paddle.baseWidth = 150 * cachedScale;
                    addTimedPowerUp(type, difficultyMultiplier);
                    break;
                case 'shrink':
                    paddle.baseWidth = 60 * cachedScale;
                    addTimedPowerUp(type, difficultyMultiplier);
                    break;
                case 'multiball':
                    const currentBalls = [...balls];
                    currentBalls.forEach(ball => {
                        if (!ball.stuck) {
                            const newBall1 = new Ball(ball.x, ball.y);
                            newBall1.dx = ball.dx * 0.8 - ball.dy * 0.3;
                            newBall1.dy = ball.dy * 0.8 + ball.dx * 0.3;
                            newBall1.stuck = false;
                            newBall1.speed = ball.speed;
                            balls.push(newBall1);
                            
                            const newBall2 = new Ball(ball.x, ball.y);
                            newBall2.dx = ball.dx * 0.8 + ball.dy * 0.3;
                            newBall2.dy = ball.dy * 0.8 - ball.dx * 0.3;
                            newBall2.stuck = false;
                            newBall2.speed = ball.speed;
                            balls.push(newBall2);
                        }
                    });
                    break;
                case 'slow':
                    balls.forEach(ball => {
                        ball.speed = ball.baseSpeed * 0.6;
                        const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        if (magnitude > 0) {
                            ball.dx = (ball.dx / magnitude) * ball.speed;
                            ball.dy = (ball.dy / magnitude) * ball.speed;
                        }
                    });
                    addTimedPowerUp(type, difficultyMultiplier);
                    break;
                case 'bazooka':
                    balls.forEach(ball => ball.bazooka = true);
                    addTimedPowerUp(type, difficultyMultiplier);
                    break;
                case 'life':
                    gameState.lives++;
                    break;
            }
        }
        
        function addTimedPowerUp(type, difficultyMultiplier) {
            const duration = POWER_UP_TYPES[type].duration * difficultyMultiplier;
            const existing = activePowerUps.find(p => p.type === type);
            if (existing) {
                existing.endTime = Date.now() + duration;
            } else {
                activePowerUps.push({
                    type: type,
                    endTime: Date.now() + duration
                });
            }
        }
        
        function removePowerUp(type) {
            switch (type) {
                case 'expand':
                case 'shrink':
                    paddle.baseWidth = 100 * cachedScale;
                    break;
                case 'slow':
                    balls.forEach(ball => {
                        ball.speed = ball.baseSpeed;
                        const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        if (magnitude > 0) {
                            ball.dx = (ball.dx / magnitude) * ball.speed;
                            ball.dy = (ball.dy / magnitude) * ball.speed;
                        }
                    });
                    break;
                case 'bazooka':
                    balls.forEach(ball => ball.bazooka = false);
                    break;
            }
        }
        
        // ===== GAME STATE FUNCTIONS =====
        function levelComplete() {
            LEDController.levelComplete();
            gameState.screen = 'levelcomplete';
            gameState.level++;
            if (gameState.level > CONFIG.MAX_LEVEL) {
                gameState.level = 1;
            }
            saveGameData();
        }
        
        function gameOver() {
            LEDController.gameOver();
            gameState.screen = 'gameover';
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
            }
            saveGameData();
        }
        
        // ===== UTILITY FUNCTIONS =====
        function resetActivity() {
            gameState.lastActivity = Date.now();
            if (gameState.blanked) {
                unblankScreen();
            }
        }
        
        function checkScreenBlanking() {
            if (gameState.screen !== 'playing' || gameState.blanked) return;
            
            const now = Date.now();
            if (now - gameState.lastActivity > CONFIG.SCREEN_BLANK_TIMEOUT) {
                blankScreen();
            }
        }
        
        function blankScreen() {
            gameState.blanked = true;
            blankedScreen.style.display = 'flex';
        }
        
        function unblankScreen() {
            gameState.blanked = false;
            blankedScreen.style.display = 'none';
            gameState.lastActivity = Date.now();
        }
        
        // ===== DATA PERSISTENCE =====
        function loadGameData() {
            try {
                const data = localStorage.getItem('brickBreakerData');
                if (data) {
                    const parsed = JSON.parse(data);
                    gameState.highScore = parsed.highScore || 0;
                    gameState.totalBricksDestroyed = parsed.totalBricksDestroyed || 0;
                }
            } catch (e) {
                console.log('Could not load game data');
            }
        }
        
        function saveGameData() {
            try {
                const data = {
                    highScore: gameState.highScore,
                    totalBricksDestroyed: gameState.totalBricksDestroyed
                };
                localStorage.setItem('brickBreakerData', JSON.stringify(data));
            } catch (e) {
                console.log('Could not save game data');
            }
        }
        
        // ===== EVENT HANDLERS =====
        function setupEventListeners() {
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('click', handleClick);
            blankedScreen.addEventListener('touchstart', unblankScreen);
            blankedScreen.addEventListener('click', unblankScreen);
            
            window.addEventListener('resize', () => {
                setupCanvas();
                createBricks();
            });
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            resetActivity();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (gameState.screen === 'playing') {
                paddle.setTargetX(x);
                
                if (!gameState.ballLaunched && balls[0] && balls[0].stuck) {
                    balls[0].launch();
                    gameState.ballLaunched = true;
                }
            }
            
            handleClick(e, x, y);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            resetActivity();
            
            if (gameState.screen === 'playing') {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                paddle.setTargetX(x);
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            resetActivity();
        }
        
        function handleClick(e, touchX, touchY) {
            let x, y;
            
            if (touchX !== undefined && touchY !== undefined) {
                x = touchX;
                y = touchY;
            } else {
                const rect = canvas.getBoundingClientRect();
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            resetActivity();
            
            if (gameState.screen === 'difficulty') {
                const buttonWidth = 200;
                const buttonHeight = 60;
                const buttonSpacing = 80;
                const startY = canvas.height / 2;
                
                Object.keys(DIFFICULTY_CONFIGS).forEach((key, index) => {
                    const buttonY = startY + index * buttonSpacing;
                    if (x > canvas.width / 2 - buttonWidth / 2 &&
                        x < canvas.width / 2 + buttonWidth / 2 &&
                        y > buttonY &&
                        y < buttonY + buttonHeight) {
                        gameState.difficulty = key;
                        gameState.screen = 'start';
                    }
                });
            } else if (gameState.screen === 'start') {
                if (x > canvas.width / 2 - 100 &&
                    x < canvas.width / 2 + 100 &&
                    y > canvas.height - 150 &&
                    y < canvas.height - 90) {
                    gameState.screen = 'playing';
                    resetGame();
                }
            } else if (gameState.screen === 'playing') {
                if (x > 10 && x < 60 && y > 10 && y < 45) {
                    gameState.screen = 'paused';
                }
            } else if (gameState.screen === 'paused') {
                if (x > canvas.width / 2 - 100 &&
                    x < canvas.width / 2 + 100 &&
                    y > canvas.height / 2 + 20 &&
                    y < canvas.height / 2 + 80) {
                    gameState.screen = 'playing';
                }
            } else if (gameState.screen === 'gameover') {
                if (x > canvas.width / 2 - 100 &&
                    x < canvas.width / 2 + 100 &&
                    y > canvas.height - 150 &&
                    y < canvas.height - 90) {
                    gameState.screen = 'difficulty';
                    gameState.difficulty = null;
                }
            } else if (gameState.screen === 'levelcomplete') {
                if (x > canvas.width / 2 - 100 &&
                    x < canvas.width / 2 + 100 &&
                    y > canvas.height / 2 + 80 &&
                    y < canvas.height / 2 + 140) {
                    resetLevel();
                    gameState.screen = 'playing';
                }
            }
        }
        
        // ===== GAME LOOP =====
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime || CONFIG.FIXED_DELTA;
            lastTime = timestamp;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ===== START GAME =====
        window.addEventListener('load', init);
        
        // ===== WATCHDOG TIMER =====
        setInterval(() => {
            try {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/watchdog', true);
                xhr.send();
            } catch (e) {
                console.log('Watchdog feed failed');
            }
        }, 30000);
    </script>
</body>
</html>